# 2023 每日积累整理

## [2023-01-03] 统计当前使用者git项目提交代码行数命令问题

### 基本命令

```
git log --since="2022-01-01" --before="2023-01-01" --author="$(git config --get user.email)" --pretty=tformat: --numstat | awk '{ add += $1 ; subs += $2 ; loc += $1 + $2 } END { printf "added lines: %s removed lines : %s total lines: %s\n",add,subs,loc }'
```

### 拓展：改为接受命令行执行 sh

```
# test.sh
# sh test.sh 2022-01-01 2023-01-01
start=$1
end=$2
author="$(git config --get user.email)"

echo "开始日期: ${start}"
echo "结束日期: ${end}"
echo "git user: ${author}"

git log --since="${start}" --before="${end}" --author="$(git config --get user.email)" --pretty=tformat: --numstat | awk '{ add += $1 ; subs += $2 ; loc1 += $1 - $2 ;loc2 += $1 + $2 } END { printf "新增: %s，删除: %s，净增: %s，总计修改: %s\n",add,subs,loc1,loc2 }'
```

#### 小问题

命令最开始使用的是 `gawk`，使用时报错 ` command not found: gawk`，更换为 `awk` 则成功运行。

## [2023-01-04] 有关设置服务器定时任务的构想与步骤拆解

> 买了服务器不知道干啥用，想想怎么能有效把服务器利用起来。

### 步骤

1. 编写简单的脚本 `demo.sh`，脚本内容为：`df -h`。
2. 获取运行结果，保存成文件 `demo-res.txt`。[参考](https://blog.csdn.net/weixin_38370441/article/details/115487340)
   - 每次输出内容如果相同，用日期 `date` 进行简单区分。 
   - sh 日期格式化：`date "+%Y-%m-%d %H:%M:%S"`（注意需要使用 "" 将格式化文本包起来，留有空格会被认为是 2 个命令而报错）。[参考](https://cloud.tencent.com/developer/article/1720961)
3. 使用电子邮件发送 `demo-res.txt`。
   - linux 下通常使用 mailx 发送邮件。
   - mailx 命令：`echo "This is the mail body" | mail -s "Subject" 123@qq.com`
   - mail -s "Hello from jsdig.com by shell" 123@qq.com
   - echo "hello,this is the content of mail.welcome to www.jsdig.com" | mail -s "Hello from jsdig.com by pipe" 123@qq.com
   - 卡住了，走不下去。
4. 定时每天 11 点发送。
   - 使用 linux 常用命令 crontab，一般自带。
     - crontab 是否存在：`rpm -qa | grep crontab`。
     - crontab 是否在运行：`systemctl status crond`，`active (running)` 表示在运行，`inactive (dead)` 表示未运行。
     - crontab 启动：`systemctl start crond` 。
     - [其余常用命令](https://zhuanlan.zhihu.com/p/115082330)。
   - crontab [常用写法](https://www.runoob.com/w3cnote/linux-crontab-tasks.html)。
   - crontab [未正常运行原因参考](https://blog.csdn.net/u011734144/article/details/54576469)。
     - 练手过程中遇到的是路径问题，crontab 实际上是运行了的，但是因为 sh 脚本中 `> demo-res.txt` 是相对路径，所以写入到了 crontab 目录下的 `demo-res.txt`，修改为绝对路径则正常运行。
   - crontab 运行后的其他问题：
     - 有关 `crontab -e` 和 `crontab /etc/crontab` 执行问题：经测试两者分别独立，`crontab -e` 为当前用户计划，不需要也不能指定用户（会报错）；`crontab /etc/crontab` 为总体定时计划，需要指定用户。
     - 运行 `demo.sh` 脚本后会莫名其妙的收到邮件，命令行提示 `You have new mail`。进入 `/etc/mail` 目录下发现 `demo.sh` 脚本的输出结果被输出到了`运行用户名`命名的文件内，原因不明。

#### sh 脚本

```
date "+%Y-%m-%d %H:%M:%S"> demo-res.txt
df -h >> demo-res.txt
cat demo-res.txt
```

#### 后续扩展思考

1. 服务器可以执行哪些脚本？
2. 可以执行的是否只有脚本？
3. 如何定时爬取 steam 打折游戏列表？
4. 以日常维护来说，服务器需要哪些定时任务？
5. 其他项目是否需要定时任务？

#### 好文参考

- [Crontab 定时任务](https://my.oschina.net/u/4313887/blog/3710661)
- [云服务器定时任务方案cron（全流程）](https://juejin.cn/post/6913131133597122568)
- [linux 常用命令](http://mcos.top/archives/linux-chang-yong-ming-ling--wen-jian-cao-zuo--ding-shi-ren-wu--cha-kan-fu-wu-qi-xin-xi-)

## [2023-01-09] 有关数据上报的学习与经验积累
> 参考：[你只会用前端数据埋点 SDK 吗？](https://mp.weixin.qq.com/s/1VWYBLMdl94pyBpOl3p5hQ)

### sdk 存在的意义 - 为什么需要前端数据埋点？

从个人体会，前端埋点的最大意义便是及早发现问题，进而解决问题。后端服务因为有服务器日志方便回溯数据与用户操作，对于问题的定位是非常简洁且高效的。但是前端页面上线后，只能通过用户的描述对操作复现，定位问题成本很高。

而且前端所谓直接应对用户的页面，所以一旦出现 bug 会被用户第一时间感知到。而因为单测编写难度（以及个人懒散），前端工程很多时候都是裸奔上线，解决 bug 只能靠手工测试。对于动辄千万行的代码而言，总有那么几条漏网之鱼。因此每次上线前后都是最担心的，不知道就弄了什么定时炸弹上去。

所以前端埋点的最大意义便是：

- 错误收集
- 性能搜集
- 行为收集

重要性分先后。

### 前端错误收集

前端错误收集分两种：运行时错误与接口错误。

## [2023-01-12] 文章阅读

- [RBAC用户、角色、权限、组设计方案](https://zhuanlan.zhihu.com/p/63769951)
- [【presto】函数大全](https://blog.csdn.net/lz6363/article/details/123769785)
- [git取消对某个文件的跟踪](https://blog.csdn.net/qq_37858386/article/details/105133639)

### git 取消文件 sh 脚本

```
# show-rm-git.sh
doc=$1
echo "即将删除 ${doc} 下的："
git rm -r -n --cached "${doc}"
```

```
# rm-git.sh
doc=$1
echo "已删除 ${doc} 下的："
git rm -r --cached "${doc}"
```

## [2023-01-13] 有关流程图与架构图

- [流程图标准](https://zhuanlan.zhihu.com/p/67533900)
- [如何画好一张架构图](https://juejin.cn/post/6844904192394412040)
> 基本没看懂。
- [架构图和时序图](https://www.imgeek.org/article/825360037)
- [作图](https://www.processon.com/)
> 画图真难，比写代码难的多。

## [2023-01-14] nestjs 打包问题

- [Nest项目部署的最佳方式](https://juejin.cn/post/7065724860688760862)

nestjs 打包部署也是个老大难的问题，主要就是在 build 时 nestjs 并未将 node_modules/ 下的文件打入 dist 文件夹内，只是简单的进行了引用链接。常用的做法有：

1. 将 nestjs 使用的依赖包打成 docker，然后以 docker 镜像 + dist 的方式进行使用。
2. 整个项目打成 zip 包部署（体积比较大）。
  
这边文章提供了第三种方法，引入 webpack 将 node_modules/ 打入 dist 内的 main.js 中。 

## [2023-01-15] rbac 文章复读 & 数据库设计
> [RBAC用户、角色、权限、组设计方案](https://zhuanlan.zhihu.com/p/63769951) 

有关权限的细分，在[权限管理系统数据库设计](../server/权限管理系统数据库设计.md)中权限设计的拓展。

权限为单独的一张权限表：

```
  drop table if exists authorities;

    CREATE TABLE IF NOT EXISTS `authorities`(
   `id` INT UNSIGNED AUTO_INCREMENT,
   `name` VARCHAR(40) NOT NULL comment '权限名称' ,
   `type` VARCHAR(40) NOT NULL comment '权限类型',
   `status` TINYINT NOT NULL DEFAULT 0,
   PRIMARY KEY ( `id` )
)ENGINE=InnoDB DEFAULT CHARSET=utf8;
```
> 与原本相比，增加了 type 类型，保证权限并不仅仅以一种方式进行存在。有可能对菜单的访问权限、对页面元素的访问权限、对某类资源的访问权限，增加了灵活性。

增加功能操作表/限制表：

```
drop table if exists operations;

    CREATE TABLE IF NOT EXISTS `operations`(
   `id` INT UNSIGNED AUTO_INCREMENT ,
   `name` VARCHAR(40) NOT NULL comment '操作名称',
   `code` VARCHAR(40) NOT NULL comment '操作码',
   `url` VARCHAR(80) default '' comment '拦截 url',
   `father_id` INT UNSIGNED default 0 comment '父id',
   `status` TINYINT NOT NULL DEFAULT 0,
   PRIMARY KEY ( `id` )
)ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

增加权限&操作关系表

```
drop table if exists authorities_operations;
CREATE TABLE IF NOT EXISTS `authorities_operations` (
 `a_id` INT UNSIGNED COMMENT '权限id',
 `o_id` INT UNSIGNED COMMENT '操作id',
 `status` TINYINT NOT NULL DEFAULT 0,
 CONSTRAINT `authorit_o`FOREIGN KEY  (`a_id`)  REFERENCES  `authorities` (`id`),
 CONSTRAINT `operation_a` FOREIGN KEY (`o_id`) REFERENCES `operations` (`id`)
) 
```

扩展权限表后，可以对各种类型的资源进行控制。例如菜单、元素、文件：

```
drop table if exists menus;

    CREATE TABLE IF NOT EXISTS `menus`(
   `id` INT UNSIGNED AUTO_INCREMENT ,
   `name` VARCHAR(40) NOT NULL comment '菜单名称',
   `url` VARCHAR(80) default '' comment '菜单 url',
   `father_id` INT UNSIGNED default 0 comment '父级菜单 id',
   `status` TINYINT NOT NULL DEFAULT 0,
   PRIMARY KEY ( `id` )
)ENGINE=InnoDB DEFAULT CHARSET=utf8;

drop table if exists authorities_menus;

 CREATE TABLE IF NOT EXISTS  `authorities_menus` (
 `a_id` INT UNSIGNED COMMENT '权限id',
 `m_id` INT UNSIGNED COMMENT '菜单id',
 `status` TINYINT NOT NULL DEFAULT 0,
 CONSTRAINT `authority_m`FOREIGN KEY  (`a_id`)  REFERENCES  `authorities` (`id`),
 CONSTRAINT `menu_a` FOREIGN KEY (`m_id`) REFERENCES `menus` (`id`)
) 
```

通过权限菜单表，可以对权限进行扩展。

- 权限 - 菜单 - 权限_菜单。
- 权限 - 元素 - 权限_元素。
- 权限 - 文件 - 权限_文件。

#### 参考

- [MySQL的外键约束（FOREIGN KEY](https://juejin.cn/post/6965849361599168520)

## [2023-01-16] nestjs 部署探索

### 方法一：压缩打包法：连同依赖包和依赖配置一同打包进 zip 包。以 zip 包为基准提交 git。缺点：体积大。

```
tar -czvf dist.tar.gz ./dist ./node_modules ./.env
```

### 方法二：[docker 化](https://juejin.cn/post/6992508923953709064)

- `Dockerfile`

```

# Docker多阶段构建

### DEV环境 ###
FROM node:14.17.3 AS development

# 定位到容器工作目录
WORKDIR /usr/src/app
# 拷贝package.json
COPY package*.json ./


RUN npm install --unsafe-perm -ddd --registry=https://registry.npm.taobao.org
# RUN npm install glob rimraf
# RUN npm install --only=development
COPY . .
RUN npm run build


### PROD环境 ###
FROM node:14.17.3 as production

# ARG NODE_ENV=production
# ENV NODE_ENV=${NODE_ENV}

WORKDIR /usr/src/app

COPY package*.json ./

RUN npm install --unsafe-perm -ddd --registry=https://registry.npm.taobao.org
RUN npm install pm2 -g
# RUN \
#   npm config set registry https://registry.npm.taobao.org \
#   && npm install --only=production

COPY . .

# COPY --from=development /usr/src/app/dist ./dist

CMD ["node", "dist/main"]
```

- `docker-compose.yml`

```
version: '3.9'
services:
  dev:
    container_name: server-dev
    image: server-dev:1.0.0
    build:
      context: .
      target: development
      dockerfile: ./Dockerfile
    command: npm run start:debug
    # network_mode: host
    ports:
      - 8080:8080
    volumes:
      - .:/usr/src/app
      - /usr/src/app/node_modules
    restart: always
  prod:
    container_name: server-prod
    image: server-prod:1.0.0
    build:
      context: .
      target: production
      dockerfile: ./Dockerfile
    command: npm run start:prod
    network_mode: host
    # ports:
    #   - 8080:8080
    volumes:
      - .:/usr/src/app
      - /usr/src/app/node_modules
    restart: always
```
> docker-compose 有版本限制，需要在开头 version 标明。版本不同的 docker 

docker 好处是，打包体积确实小。但是 docker 源会比较大。

## [2023-01-17] 有关 vue2 生命周期的复习与整理

| 生命周期钩子 | 组件状态 | 	最佳实践 |
| :-----| :-----| :-----|
| beforeCreated | 实例初始化后，this 指向创建的实例。但是不能访问到 data、computed、watch 和 methods 上的方法和数据 | 常用于初始化非响应式变量 |
| created | 实例创建完成，可访问 data、computed、watch 和 methods 上的方法和数据未挂载到 DOM，不能访问 $el 属性，$ref 属性内容为空数组| 常用于简单的 AJAX 请求，页面的初始化 |
| beforeMount | 在挂载开始之前被调用beforeMount 之前，会找到对应的 template，并编译成 render 函数|  |
| mounted | 实例挂载到 DOM 上，此时可以通过 DOM API 获取到 DOM 节点，$ref 属性可以访问|  常用于获取 VNode 信息和操作，AJAX 请求|
| beforeUpdate | 响应式数据更新时调用，发生在 Virtual DOM 打补丁前| 适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器|
| updated | Virtual DOM 重新渲染和打补丁之后调用，组件 DOM 已经更新，可执行依赖于 DOM 的操作| 避免在这个钩子函数中操作数据，可能陷入死循环|
| beforeDestroy | 实例销毁之前调用。这一步，实例仍然完全可用，this 仍能获取到实例引用| 常用于销毁定时器、解绑全局事件、销毁插件对象等操作|
| destroyed | 实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁	| |

### 额外

- [有关 vue3 生命周期的学习与整理](https://cn.vuejs.org/api/composition-api-lifecycle.html)
- url 与锚点的关系？

## [2023-01-18] 

### vue 锚点跳转

直接上代码

```
<template>
  <div>
    <div id="header">
      <el-button
        @click="toDetail(`${anchor}${anchor}${index}`)"
        v-for="(anchor, index) in anchors"
        :key="anchor"
        >to：{{ anchor }}{{ anchor }}{{ index }}</el-button
      >
    </div>

    <div
      v-for="(anchor, index) in anchors"
      :key="index"
      :id="`${anchor}${anchor}${index}`"
      style="width: 800px; height: 400px; border: 1px solid red; margin: 12px;position: relative;"
    >
      <h3 style="padding: 8px; border-bottom: 1px solid red; margin: 12px">
        {{ anchor }}-{{ anchor }}-{{ index }}
      </h3>
      <p style="margin: 8px">{{ anchor }}{{ anchor }}{{ index }}</p>
      <el-button @click="toDetail('header')" style="position: absolute;right: 12px;bottom: 12px;">回去</el-button>
    </div>
  </div>
</template>

<script>
export default {
  name: 'DemoOne',
  data: () => ({
    temp: 'demo',
    anchors: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'],
  }),
  mounted() {
    const {
      hash = ''
    } = location

    if (hash && hash.slice) {
      this.toDetail(hash.slice(1))
    }
  },
  methods: {
    toDetail(anchorId) {
      console.log(anchorId)
      const scrollDom = document.getElementById(anchorId);
      if (scrollDom) {
        scrollDom.scrollIntoView({
          behavior: 'smooth',
        });
      }

    },
  },
};
</script>


<style>
</style>
```

#### [另一种跳转方法](https://www.jianshu.com/p/2ad8c8b5bf75)

麻烦了些，但是可以避免 hash 路由与锚点冲突。

### 有关拆解的问题

```
let { result = 'default' } = {};
console.log(result); // 'default'

let { result = 'default' } = {result: undefined};
console.log(result); // null

let { result = 'default' } = {result: 1};
console.log(result); // 1

let { result = 'default' } = {result: null};
console.log(result); // null
```
> 所以后端没事儿别瞎鸡儿返回数据

### 有关如何在控制台输出 badge 格式的文字

```
var success='#54c22b'
var primary='#2873b2'
var label='#606060'
var error='red'
let showBadge = function (label ,text, labelColor, textColor) {
        console.log(
            '%c '.concat(label, ' %c ').concat(text, ' '), 
            'padding: 1px; border-radius: 3px 0 0 3px;color: #fff;background: '.concat(labelColor, ';'),
            'padding: 1px; border-radius: 0 3px 3px 0;color: #fff;background: '.concat(textColor, ';'))
      }
showBadge('label', 'txt',label, primary)
```

## [2023-01-20] 为什么程序员讨厌低代码
> [为什么程序员讨厌低代码](https://www.zhihu.com/question/561025857/answer/2734260311)

目前接手维护低代码相关的一个系统，比较难受，主要原因有以下几点：

- 入门成本高，尤其是框架底层经过大量的扩展，功能其实多如牛毛，没有一个人可以完全掌握。很多时候，会做一些重复的开发。
- 码表混乱，尤其是页面级码表。统一不了码表，在码表扩充或者减少时，很容易漏掉某些页面。
- 页面修改无法追溯，代码级的修改可以通过 git 进行方便的回滚、检出；配置文件不列入 git，所以改了什么东西完全看不出来。
- 代码配置同步问题。包括测试环境和生产环境配置往往不同步，尤其是在一些小改动直接在生产环境修改而未同步给测试环境。测试环境如果不知道，依然以测试环境的最新版本版本进行开发，很容易上线配置后覆盖对应功能。其次多人协作开发时，如果不同需求对一个配置进行了修改，在没有 git 的情况下很容易互相覆盖。

## [2023-01-22] 有关新的一年技术研究和发展构想（暂定）。

- vue3 [源码学习](https://nlrx-wjc.github.io/Learn-Vue-Source-Code/start/)、[项目研究 & 练手](https://github.com/vue3/awesome-github-vue-latest)。
- 基于 vue3 的前端脚手架。
- Ci/Cd、Jeknins groovy 设置打包与部署。 
- 组件整理 & 组件库建设。。
- 常用工具代码整理 & 工具库建设。
- 基于 nestjs 的完整 rbac 权限控制服务端。
- rap2 mock 优化：根据 request 参数返回不同的值。
- docker 部署（包括前端部署与后端部署）。
- 埋点 sdk 相关研究。

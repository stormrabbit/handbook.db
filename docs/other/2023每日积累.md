# 2023 每日积累整理

## [2023-01-03] 统计当前使用者git项目提交代码行数命令问题

### 基本命令

```
git log --since="2022-01-01" --before="2023-01-01" --author="$(git config --get user.email)" --pretty=tformat: --numstat | awk '{ add += $1 ; subs += $2 ; loc += $1 + $2 } END { printf "added lines: %s removed lines : %s total lines: %s\n",add,subs,loc }'
```

### 拓展：改为接受命令行执行 sh

```
# test.sh
# sh test.sh 2022-01-01 2023-01-01
start=$1
end=$2
author="$(git config --get user.email)"

echo "开始日期: ${start}"
echo "结束日期: ${end}"
echo "git user: ${author}"

git log --since="${start}" --before="${end}" --author="$(git config --get user.email)" --pretty=tformat: --numstat | awk '{ add += $1 ; subs += $2 ; loc1 += $1 - $2 ;loc2 += $1 + $2 } END { printf "新增: %s，删除: %s，净增: %s，总计修改: %s\n",add,subs,loc1,loc2 }'
```

#### 小问题

命令最开始使用的是 `gawk`，使用时报错 ` command not found: gawk`，更换为 `awk` 则成功运行。

## [2023-01-04] 有关设置服务器定时任务的构想与步骤拆解

> 买了服务器不知道干啥用，想想怎么能有效把服务器利用起来。

### 步骤

1. 编写简单的脚本 `demo.sh`，脚本内容为：`df -h`。
2. 获取运行结果，保存成文件 `demo-res.txt`。[参考](https://blog.csdn.net/weixin_38370441/article/details/115487340)
   - 每次输出内容如果相同，用日期 `date` 进行简单区分。 
   - sh 日期格式化：`date "+%Y-%m-%d %H:%M:%S"`（注意需要使用 "" 将格式化文本包起来，留有空格会被认为是 2 个命令而报错）。[参考](https://cloud.tencent.com/developer/article/1720961)
3. 使用电子邮件发送 `demo-res.txt`。
   - linux 下通常使用 mailx 发送邮件。
   - mailx 命令：`echo "This is the mail body" | mail -s "Subject" 123@qq.com`
   - mail -s "Hello from jsdig.com by shell" 123@qq.com
   - echo "hello,this is the content of mail.welcome to www.jsdig.com" | mail -s "Hello from jsdig.com by pipe" 123@qq.com
   - 卡住了，走不下去。
4. 定时每天 11 点发送。
   - 使用 linux 常用命令 crontab，一般自带。
     - crontab 是否存在：`rpm -qa | grep crontab`。
     - crontab 是否在运行：`systemctl status crond`，`active (running)` 表示在运行，`inactive (dead)` 表示未运行。
     - crontab 启动：`systemctl start crond` 。
     - [其余常用命令](https://zhuanlan.zhihu.com/p/115082330)。
   - crontab [常用写法](https://www.runoob.com/w3cnote/linux-crontab-tasks.html)。
   - crontab [未正常运行原因参考](https://blog.csdn.net/u011734144/article/details/54576469)。
     - 练手过程中遇到的是路径问题，crontab 实际上是运行了的，但是因为 sh 脚本中 `> demo-res.txt` 是相对路径，所以写入到了 crontab 目录下的 `demo-res.txt`，修改为绝对路径则正常运行。
   - crontab 运行后的其他问题：
     - 有关 `crontab -e` 和 `crontab /etc/crontab` 执行问题：经测试两者分别独立，`crontab -e` 为当前用户计划，不需要也不能指定用户（会报错）；`crontab /etc/crontab` 为总体定时计划，需要指定用户。
     - 运行 `demo.sh` 脚本后会莫名其妙的收到邮件，命令行提示 `You have new mail`。进入 `/etc/mail` 目录下发现 `demo.sh` 脚本的输出结果被输出到了`运行用户名`命名的文件内，原因不明。

#### sh 脚本

```
date "+%Y-%m-%d %H:%M:%S"> demo-res.txt
df -h >> demo-res.txt
cat demo-res.txt
```

#### 后续扩展思考

1. 服务器可以执行哪些脚本？
2. 可以执行的是否只有脚本？
3. 如何定时爬取 steam 打折游戏列表？
4. 以日常维护来说，服务器需要哪些定时任务？
5. 其他项目是否需要定时任务？

#### 好文参考

- [Crontab 定时任务](https://my.oschina.net/u/4313887/blog/3710661)
- [云服务器定时任务方案cron（全流程）](https://juejin.cn/post/6913131133597122568)
- [linux 常用命令](http://mcos.top/archives/linux-chang-yong-ming-ling--wen-jian-cao-zuo--ding-shi-ren-wu--cha-kan-fu-wu-qi-xin-xi-)

## [2023-01-09] 有关数据上报的学习与经验积累
> 参考：[你只会用前端数据埋点 SDK 吗？](https://mp.weixin.qq.com/s/1VWYBLMdl94pyBpOl3p5hQ)

### sdk 存在的意义 - 为什么需要前端数据埋点？

从个人体会，前端埋点的最大意义便是及早发现问题，进而解决问题。后端服务因为有服务器日志方便回溯数据与用户操作，对于问题的定位是非常简洁且高效的。但是前端页面上线后，只能通过用户的描述对操作复现，定位问题成本很高。

而且前端所谓直接应对用户的页面，所以一旦出现 bug 会被用户第一时间感知到。而因为单测编写难度（以及个人懒散），前端工程很多时候都是裸奔上线，解决 bug 只能靠手工测试。对于动辄千万行的代码而言，总有那么几条漏网之鱼。因此每次上线前后都是最担心的，不知道就弄了什么定时炸弹上去。

所以前端埋点的最大意义便是：

- 错误收集
- 性能搜集
- 行为收集

重要性分先后。

### 前端错误收集

前端错误收集分两种：运行时错误与接口错误。

## [2023-01-12] 文章阅读

- [RBAC用户、角色、权限、组设计方案](https://zhuanlan.zhihu.com/p/63769951)
- [【presto】函数大全](https://blog.csdn.net/lz6363/article/details/123769785)
- [git取消对某个文件的跟踪](https://blog.csdn.net/qq_37858386/article/details/105133639)

### git 取消文件 sh 脚本

```
# show-rm-git.sh
doc=$1
echo "即将删除 ${doc} 下的："
git rm -r -n --cached "${doc}"
```

```
# rm-git.sh
doc=$1
echo "已删除 ${doc} 下的："
git rm -r --cached "${doc}"
```

## [2023-01-13] 有关流程图与架构图

- [流程图标准](https://zhuanlan.zhihu.com/p/67533900)
- [如何画好一张架构图](https://juejin.cn/post/6844904192394412040)
> 基本没看懂。
- [架构图和时序图](https://www.imgeek.org/article/825360037)
- [作图](https://www.processon.com/)
> 画图真难，比写代码难的多。

## [2023-01-14] nestjs 打包问题

- [Nest项目部署的最佳方式](https://juejin.cn/post/7065724860688760862)

nestjs 打包部署也是个老大难的问题，主要就是在 build 时 nestjs 并未将 node_modules/ 下的文件打入 dist 文件夹内，只是简单的进行了引用链接。常用的做法有：

1. 将 nestjs 使用的依赖包打成 docker，然后以 docker 镜像 + dist 的方式进行使用。
2. 整个项目打成 zip 包部署（体积比较大）。
  
这边文章提供了第三种方法，引入 webpack 将 node_modules/ 打入 dist 内的 main.js 中。 

## [2023-01-15] rbac 文章复读 & 数据库设计
> [RBAC用户、角色、权限、组设计方案](https://zhuanlan.zhihu.com/p/63769951) 

有关权限的细分，在[权限管理系统数据库设计](../server/权限管理系统数据库设计.md)中权限设计的拓展。

权限为单独的一张权限表：

```
  drop table if exists authorities;

    CREATE TABLE IF NOT EXISTS `authorities`(
   `id` INT UNSIGNED AUTO_INCREMENT,
   `name` VARCHAR(40) NOT NULL comment '权限名称' ,
   `type` VARCHAR(40) NOT NULL comment '权限类型',
   `status` TINYINT NOT NULL DEFAULT 0,
   PRIMARY KEY ( `id` )
)ENGINE=InnoDB DEFAULT CHARSET=utf8;
```
> 与原本相比，增加了 type 类型，保证权限并不仅仅以一种方式进行存在。有可能对菜单的访问权限、对页面元素的访问权限、对某类资源的访问权限，增加了灵活性。

增加功能操作表/限制表：

```
drop table if exists operations;

    CREATE TABLE IF NOT EXISTS `operations`(
   `id` INT UNSIGNED AUTO_INCREMENT ,
   `name` VARCHAR(40) NOT NULL comment '操作名称',
   `code` VARCHAR(40) NOT NULL comment '操作码',
   `url` VARCHAR(80) default '' comment '拦截 url',
   `father_id` INT UNSIGNED default 0 comment '父id',
   `status` TINYINT NOT NULL DEFAULT 0,
   PRIMARY KEY ( `id` )
)ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

增加权限&操作关系表

```
drop table if exists authorities_operations;
CREATE TABLE IF NOT EXISTS `authorities_operations` (
 `a_id` INT UNSIGNED COMMENT '权限id',
 `o_id` INT UNSIGNED COMMENT '操作id',
 `status` TINYINT NOT NULL DEFAULT 0,
 CONSTRAINT `authorit_o`FOREIGN KEY  (`a_id`)  REFERENCES  `authorities` (`id`),
 CONSTRAINT `operation_a` FOREIGN KEY (`o_id`) REFERENCES `operations` (`id`)
) 
```

扩展权限表后，可以对各种类型的资源进行控制。例如菜单、元素、文件：

```
drop table if exists menus;

    CREATE TABLE IF NOT EXISTS `menus`(
   `id` INT UNSIGNED AUTO_INCREMENT ,
   `name` VARCHAR(40) NOT NULL comment '菜单名称',
   `url` VARCHAR(80) default '' comment '菜单 url',
   `father_id` INT UNSIGNED default 0 comment '父级菜单 id',
   `status` TINYINT NOT NULL DEFAULT 0,
   PRIMARY KEY ( `id` )
)ENGINE=InnoDB DEFAULT CHARSET=utf8;

drop table if exists authorities_menus;

 CREATE TABLE IF NOT EXISTS  `authorities_menus` (
 `a_id` INT UNSIGNED COMMENT '权限id',
 `m_id` INT UNSIGNED COMMENT '菜单id',
 `status` TINYINT NOT NULL DEFAULT 0,
 CONSTRAINT `authority_m`FOREIGN KEY  (`a_id`)  REFERENCES  `authorities` (`id`),
 CONSTRAINT `menu_a` FOREIGN KEY (`m_id`) REFERENCES `menus` (`id`)
) 
```

通过权限菜单表，可以对权限进行扩展。

- 权限 - 菜单 - 权限_菜单。
- 权限 - 元素 - 权限_元素。
- 权限 - 文件 - 权限_文件。

#### 参考

- [MySQL的外键约束（FOREIGN KEY](https://juejin.cn/post/6965849361599168520)

## [2023-01-16] nestjs 部署探索

### 方法一：压缩打包法：连同依赖包和依赖配置一同打包进 zip 包。以 zip 包为基准提交 git。缺点：体积大。

```
tar -czvf dist.tar.gz ./dist ./node_modules ./.env
```

### 方法二：[docker 化](https://juejin.cn/post/6992508923953709064)

- `Dockerfile`

```

# Docker多阶段构建

### DEV环境 ###
FROM node:14.17.3 AS development

# 定位到容器工作目录
WORKDIR /usr/src/app
# 拷贝package.json
COPY package*.json ./


RUN npm install --unsafe-perm -ddd --registry=https://registry.npm.taobao.org
# RUN npm install glob rimraf
# RUN npm install --only=development
COPY . .
RUN npm run build


### PROD环境 ###
FROM node:14.17.3 as production

# ARG NODE_ENV=production
# ENV NODE_ENV=${NODE_ENV}

WORKDIR /usr/src/app

COPY package*.json ./

RUN npm install --unsafe-perm -ddd --registry=https://registry.npm.taobao.org
RUN npm install pm2 -g
# RUN \
#   npm config set registry https://registry.npm.taobao.org \
#   && npm install --only=production

COPY . .

# COPY --from=development /usr/src/app/dist ./dist

CMD ["node", "dist/main"]
```

- `docker-compose.yml`

```
version: '3.9'
services:
  dev:
    container_name: server-dev
    image: server-dev:1.0.0
    build:
      context: .
      target: development
      dockerfile: ./Dockerfile
    command: npm run start:debug
    # network_mode: host
    ports:
      - 8080:8080
    volumes:
      - .:/usr/src/app
      - /usr/src/app/node_modules
    restart: always
  prod:
    container_name: server-prod
    image: server-prod:1.0.0
    build:
      context: .
      target: production
      dockerfile: ./Dockerfile
    command: npm run start:prod
    network_mode: host
    # ports:
    #   - 8080:8080
    volumes:
      - .:/usr/src/app
      - /usr/src/app/node_modules
    restart: always
```
> docker-compose 有版本限制，需要在开头 version 标明。版本不同的 docker 

docker 好处是，打包体积确实小。但是 docker 源会比较大。

## [2023-01-17] 有关 vue2 生命周期的复习与整理

| 生命周期钩子  | 组件状态                                                                                                                   | 最佳实践                                                     |
| :------------ | :------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------- |
| beforeCreated | 实例初始化后，this 指向创建的实例。但是不能访问到 data、computed、watch 和 methods 上的方法和数据                          | 常用于初始化非响应式变量                                     |
| created       | 实例创建完成，可访问 data、computed、watch 和 methods 上的方法和数据未挂载到 DOM，不能访问 $el 属性，$ref 属性内容为空数组 | 常用于简单的 AJAX 请求，页面的初始化                         |
| beforeMount   | 在挂载开始之前被调用beforeMount 之前，会找到对应的 template，并编译成 render 函数                                          |                                                              |
| mounted       | 实例挂载到 DOM 上，此时可以通过 DOM API 获取到 DOM 节点，$ref 属性可以访问                                                 | 常用于获取 VNode 信息和操作，AJAX 请求                       |
| beforeUpdate  | 响应式数据更新时调用，发生在 Virtual DOM 打补丁前                                                                          | 适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器 |
| updated       | Virtual DOM 重新渲染和打补丁之后调用，组件 DOM 已经更新，可执行依赖于 DOM 的操作                                           | 避免在这个钩子函数中操作数据，可能陷入死循环                 |
| beforeDestroy | 实例销毁之前调用。这一步，实例仍然完全可用，this 仍能获取到实例引用                                                        | 常用于销毁定时器、解绑全局事件、销毁插件对象等操作           |
| destroyed     | 实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁                 |                                                              |

### 额外

- [有关 vue3 生命周期的学习与整理](https://cn.vuejs.org/api/composition-api-lifecycle.html)
- url 与锚点的关系？

## [2023-01-18] 

### vue 锚点跳转

直接上代码

```
<template>
  <div>
    <div id="header">
      <el-button
        @click="toDetail(`${anchor}${anchor}${index}`)"
        v-for="(anchor, index) in anchors"
        :key="anchor"
        >to：{{ anchor }}{{ anchor }}{{ index }}</el-button
      >
    </div>

    <div
      v-for="(anchor, index) in anchors"
      :key="index"
      :id="`${anchor}${anchor}${index}`"
      style="width: 800px; height: 400px; border: 1px solid red; margin: 12px;position: relative;"
    >
      <h3 style="padding: 8px; border-bottom: 1px solid red; margin: 12px">
        {{ anchor }}-{{ anchor }}-{{ index }}
      </h3>
      <p style="margin: 8px">{{ anchor }}{{ anchor }}{{ index }}</p>
      <el-button @click="toDetail('header')" style="position: absolute;right: 12px;bottom: 12px;">回去</el-button>
    </div>
  </div>
</template>

<script>
export default {
  name: 'DemoOne',
  data: () => ({
    temp: 'demo',
    anchors: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'],
  }),
  mounted() {
    const {
      hash = ''
    } = location

    if (hash && hash.slice) {
      this.toDetail(hash.slice(1))
    }
  },
  methods: {
    toDetail(anchorId) {
      console.log(anchorId)
      const scrollDom = document.getElementById(anchorId);
      if (scrollDom) {
        scrollDom.scrollIntoView({
          behavior: 'smooth',
        });
      }

    },
  },
};
</script>


<style>
</style>
```

#### [另一种跳转方法](https://www.jianshu.com/p/2ad8c8b5bf75)

麻烦了些，但是可以避免 hash 路由与锚点冲突。

### 有关拆解的问题

```
let { result = 'default' } = {};
console.log(result); // 'default'

let { result = 'default' } = {result: undefined};
console.log(result); // null

let { result = 'default' } = {result: 1};
console.log(result); // 1

let { result = 'default' } = {result: null};
console.log(result); // null
```
> 所以后端没事儿别瞎鸡儿返回数据

### 有关如何在控制台输出 badge 格式的文字

```
var success='#54c22b'
var primary='#2873b2'
var label='#606060'
var error='red'
let showBadge = function (label ,text, labelColor, textColor) {
        console.log(
            '%c '.concat(label, ' %c ').concat(text, ' '), 
            'padding: 1px; border-radius: 3px 0 0 3px;color: #fff;background: '.concat(labelColor, ';'),
            'padding: 1px; border-radius: 0 3px 3px 0;color: #fff;background: '.concat(textColor, ';'))
      }
showBadge('label', 'txt',label, primary)
```

## [2023-01-20] 为什么程序员讨厌低代码
> [为什么程序员讨厌低代码](https://www.zhihu.com/question/561025857/answer/2734260311)

目前接手维护低代码相关的一个系统，比较难受，主要原因有以下几点：

- 入门成本高，尤其是框架底层经过大量的扩展，功能其实多如牛毛，没有一个人可以完全掌握。很多时候，会做一些重复的开发。
- 码表混乱，尤其是页面级码表。统一不了码表，在码表扩充或者减少时，很容易漏掉某些页面。
- 页面修改无法追溯，代码级的修改可以通过 git 进行方便的回滚、检出；配置文件不列入 git，所以改了什么东西完全看不出来。
- 代码配置同步问题。包括测试环境和生产环境配置往往不同步，尤其是在一些小改动直接在生产环境修改而未同步给测试环境。测试环境如果不知道，依然以测试环境的最新版本版本进行开发，很容易上线配置后覆盖对应功能。其次多人协作开发时，如果不同需求对一个配置进行了修改，在没有 git 的情况下很容易互相覆盖。

### [2023-01-28]补充：有关低代码平台 - 码表统一问题的吐槽&坑 

今天在维护低代码平台的码表问题，有以下几个方面的大坑&需要注意的点：

- 混乱问题：页面之间，码表互不相通，同 key 在多个页面内使用、维护困难；同页面内，有码表从接口获取、有码表从配置获取、有码表从本地代码获取，来源混乱；同页面内码表随组件走而不是页面走，相同 key 的码表多次出现。在缺少文档的情况下，后续维护人员很难掌握所有页面的所有码表。在码表变动时，难保不会出现出现遗漏的问题。
- 部分码表获取接口未区分生产环境与测试环境，进行替换时很容易使用测试的变量覆盖正式变量。
- 同一套码表在多人维护时，很容易未能充分共享造成重复工作 —— 比如对同一（从后端获取的）码表提供了多套接口。
- 对于 label、key、value，有出现同 key 不同 value，同 label 不同 key 的情况，会造成很大程度上的理解困难和维护障碍。
- 对于无用结构或者已废弃接口，在后来人接手又不敢删除的情况下，会造成配置的大量冗余。
- 一个前端用起来很爽、维护起来很操蛋、后端很反感的结构：把码表设计为 map 结构，而不是 key-value 的数组（这是反面教材）。Map 的唯一好处是可以方便的使用 key 进行获取 value 获取，但是缺点却是灾难性的：对（java）后端，map 结构无法直观的用 swagger 展示，不如对象清晰便于维护（而且还要特意做一层对象 to map 的操作）；对于前端，虽然提取 value 方便，但是填充 select 类组件需要做一步 map to array 的数据清洗操作。在低代码平台接口未能提供清洗服务的配置时，这份多余就变成了一个需要改变底层才能适配的开发难题。好孩子不要学。
- 对于一些功能相近的菜单，前端代码可以使用 mixin 等方式进行引用，方便修改；配置需要复制两份，修改时也要改两份。

### [2023-01-30]补充：惹了个乱子

今天更新配置时惹了个乱子，在替换配置的时候不慎把别的页面配置覆盖了另一个页面。在更新了时候，已经提交了配置。因为没有回溯系统，甚至连补救的机会都没有。

还好 qa 环境还有对应页面配置，复制过来调整一下把危机处理了。

针对这种情况，特意把配置存了一份到 git 里。

## [2023-01-22] 有关新的一年技术研究和发展构想（暂定）。

- vue3 [源码学习](https://nlrx-wjc.github.io/Learn-Vue-Source-Code/start/)、[项目研究 & 练手](https://github.com/vue3/awesome-github-vue-latest)。
- 基于 vue3 的前端脚手架。
- Ci/Cd、Jeknins groovy 设置打包与部署。 
- 组件整理 & 组件库建设。
- 常用工具代码整理 & 工具库建设。
- 基于 nestjs 的完整 rbac 权限控制服务端。
- rap2 mock 优化：根据 request 参数返回不同的值。
- docker 部署（包括前端部署与后端部署）。
- 埋点 sdk 相关研究

## [2023-01-25] Flutter 相关研究
> 今天看了 flutter 直播，发现 flutter 进化非常大。
- [官网](https://docs.flutter.dev/)。
- [flutter go](https://github.com/stormrabbit/flutter-go)
- [dart](https://dart.dev/
- [flutter b 站社区](https://space.bilibili.com/344928717/)

## [2023-01-30] 有关本地文档常驻构想&实现

平时经常有些文档或者常用命令需要查询，之前是使用 md 文档进行撰写与保存，但是使用起来有这么几个问题：

- 需要打开新的 ide 窗口，并选择对应路径，麻烦。
- md 文档在未预览情况下，可读性还是差了点。
> 其实主要还是开 ide 选路径麻烦，查起来也麻烦。

考虑到便携（懒），准备做如下操作：
- 把此类文档统一归到某个项目内。
- 使用本地服务器的方式启动该项目，启动后可以直接在浏览器中查看。
- 支持实时编辑，刷新预览。
- 支持命令行一键启动&重载。

文档已经归纳到项目内，本地文档系统选择：[docsify](https://docsify.js.org/#/zh-cn/)。

指定 docsify 读取目录：`docsify init ./docs`

需要在 `./docs` 目录下新建 `_sidebar.md` 并撰写目录，可是用 `node fs` 自动读取 docs 下文件并生成。

使用 `npm init` 初始化 `pacakge.json` 文件，增加 docsify 启动命令并指定端口：`"serve": "docsify serve docs --port 12345"`。

docsify 支持实时修改&预览。

编写 docsify 启动脚本：`run_docsify.sh`

```
#!/bin/bash
out="$(lsof -nP | grep LISTEN | grep 12345)"
outs=(${out//\t/ })  
docsPid=${outs[1]}
if [ ! "$docsPid" = "" ]
then
    kill $docsPid
    echo "已经关闭 pid：${docsPid}，正在重启..."
else
    echo '正在启动...'
fi
cd ~/docsify
npm run serve
```

修改 zsh 命令（或者 bash）`vim ~/.zshrc `，指定别名：

```
alias start='sh ~/docsify/run_docsify.sh'

```

重新 source 下：source ~/.zshrc

可以直接使用 start 启动文档服务。

## [2023-02-02] 增加 node 版本运行方式

使用命令行启动，多少还是有些麻烦 —— 要多开一个命令行窗口。因此又使用 node exec 写了一段 js 代码，可以直接用 pm2 启动。

| 启动方式 | 优点                          | 缺点                     |
| :------- | :---------------------------- | :----------------------- |
| 命令行   | 节省电脑资源，不用时可以关闭  | 需要多开一个命令行窗口   |
| 屏幕     | 省心，启动后不用特意开启/关闭 | 留在电脑内确实一直占资源 |

总的来说两种方式各有优劣吧。

pm2 启动 `run-node.js`：


```

const util = require("util");
const child_process = require("child_process");
// 调用util.promisify方法，返回一个promise,如const { stdout, stderr } = await exec('rm -rf build')
const exec = util.promisify(child_process.exec);

const run = async () => {
  let docsifyRunningStatusStr;
  try {
    const { stdout } = await exec("lsof -i tcp:14841");
    console.log(stdout);
    if (!!stdout) {
      docsifyRunningStatusStr = stdout;
    }
  } catch (_) {
    console.log("正在启动 docs 服务...");
  }

  try {
    if (docsifyRunningStatusStr) {
      console.log("已有服务运行，正在关闭中...");
      const [_, pid] = docsifyRunningStatusStr
        .split(" ")
        .filter((str) => !!str);
      if (pid) {
        const { stdout: closeStatus } = await exec(`kill -9 ${pid}`);
        console.log(closeStatus);
        console.log(`已关闭进程：${pid}`);
      }
    }
  } catch (error) {
    console.log(error);
  }
  try {
    await exec(
      `cd ~/docsify`
    );
    exec(`docsify serve docs --port 14841`);
    console.log("服务已启动，端口 14841");
  } catch (error) {
    console.log("启动失败：");
    console.log(error);
  }
};
run();

```

## [2023-02-06] 文章阅读与参考&工具库想法

- 文章阅读&参考
  - [MarkDown 语法参考](https://markdown.com.cn/basic-syntax/)
  - [JsDoc 写法](https://segmentfault.com/a/1190000015778930)
  - [node 运行 shell 方式参考](https://cloud.tencent.com/developer/article/1812689)
  - [web worker 加快前端渲染](https://mp.weixin.qq.com/s/HbrMoFNFWMlbkVwLol3PoA)
- 工具库构想1 todo：
  - node 执行 shell 脚本工具。
  - document 获取页面尺寸工具。
  - 封装好的 axios 接口工具。
  - 以 typesrcipt 编写。

## [2023-02-07] 文章阅读与参考&组件库构想

- 文章阅读&参考：
  - [RAP2接口管理工具使用教程](https://juejin.cn/post/6850418118772064270#heading-5)（主要是 mock 占位符）
- 组件库思考：
  - 常用 form，使用共同组建。
  - 常用 table ，带查询、分页、渲染。
  - 常用 select 表单项。
  - 多行文字一行显示/鼠标悬浮显示完整。

## [2023-02-08] [有关 js 中的码表枚举化](https://blog.csdn.net/qq_33551792/article/details/108587604)

开发中使用码表的时候，常用两种方式：

方案一：
```
const map = {
  1: '状态一',
  2: '状态二'.
  3: '状态三'
}
```
方案二：
```
const map = [
  {label:'状态一', value: 1 },
  {label:'状态二', value: 2},
  {label:'状态三', value:3 },
]
```

方案一的好处是，对于给定的 key `val`，可以很方便的替换 `map[val]` 获取值。但是一来方案一的扩展性有限，其次对于后端（尤其是 java 后端），返回一个 map 结构并不是标准的流程。

方案二的优缺点刚好和方案二想法，即对于给定的 key `val`，必须使用 `map.find( it => it.value === val)` 才能拿到特定的码表，还要处理找不到值(undefined)的情况；但是结构方便扩展，java 返回的也通常是此种类型。

但是方案一和方案二都无法解决的是，在除了值替换过程中的一些逻辑判断时提供足够的语义化支持。比如对给定的值 val，在 `1,2,3` 情况下要做特定的操作，有 `val === 1/2/3` 这就不够友好。且不说维护时会想半天 123 都是啥东西，如果需要对值进行修改，光改就要改半天。

因此应该对码表进行枚举化改造，并对枚举值提供 get 和转义操作，将所有的操作收敛到对应的常量方法中，方便对于状态的管理。

```
// 在文章的基础上进行了改造
function createEnum(definition) {
  const strToValueMap = {}
  const numToDescMap = {}
  for (const enumName of Object.keys(definition)) {
    const [value, desc] = definition[enumName]
    strToValueMap[enumName] = value
    numToDescMap[value] = desc
  }
  return {
    ...strToValueMap,
    toOptions() {
      return Object.keys(strToValueMap).map(key=> ({
        label: this.emun2Text(key),
        value: strToValueMap[key]
      }))
    },
    emun2Text(enumName) {
      return (definition[enumName] && definition[enumName][1]) || ''
    },
    value2Text(value) {
      return numToDescMap[value] || ''
    }
  }
}

```

然后有

```
// STATIS1/2/3 是瞎写的，实际应该是 APPROVE/REJECT 等更为有语义化的单词，方便代码阅读
export const STATIS = createEnum({
  STATIS1: [1, '状态1'],
  STATIS2: [2, '状态2'],
  STATIS3: [3, '状态3'],
})
```

对于 select 等组件需要的 options 选项

```
STATIS.toOptions()
```

对于需要转义的地方

```
STATIS.value2Text(val)
```

对于需要逻辑判断的地方

```
switch(val) {
  case STATIS.STATIS1:
    ....
  case STATIS.STATIS2:
    ....
  case STATIS.STATIS3:
    ....
  default:
    ....
    
}
```

当然，枚举化也有自己的问题。即对于灵活变化的码表或者量大的码表（比如城市码表、由接口获取的码表），无法使用给定的枚举值进行枚举化。还是要回归到方案二的老路上。

方案一可以通过方案二清洗数据转化的来，最好不要让后端直接返回。后端会炸毛，有结构变动或者扩充的时候前端后端会一起炸毛。


## [2023-02-09] 有关 js 全角、半角字符统计的工具

```javascript
function count(target) {
  if (typeof target === "number") {
    return `${target}`.length;
  }
  const str = `${target}`;
  let totalLength = 0;
  const list = str.split("");
  for (let i = 0; i < list.length; i++) {
    const s = list[i];
    if (s.match(/[\u0000-\u00ff]/g)) {
      //半角
      totalLength += 1;
    } else if (s.match(/[\u4e00-\u9fa5]/g)) {
      //中文
      totalLength += 2;
    } else if (s.match(/[\uff00-\uffff]/g)) {
      //全角
      totalLength += 2;
    }
  }
  return Math.floor(totalLength/ 2) ;
}

```

## [2023-02-10] 有关 typescript 中 class 和 interface 的区别

- [interface 和 class 的区别](https://juejin.cn/post/6844904126661263367)

## [2023-02-13] 13 日总结
> 首先，恭喜 time 夺冠；其次，李少牛逼；第三，真 tm 像王道少年热血漫照进现实。

### watch 中 deep、immediate 的区别
> watch route.query 一直没成功，检查的时候发现忘了加 immediate。

- deep：监听对象属性变动。
- immediate：页面首次加载时，是不会执行的。只有值发生改变才会执行。

### 随手写的常用 dialog mixins

```
<script>
export default {
  name: 'DialogMixin',
  props: {
    value: {
      type: Boolean,
      required: true,
    },
  },
  data: () => ({
    visible: false,
  }),
  watch: {
    value(newVal) {
      if (this.visible !== newVal) {
        this.visible = newVal;
      }
    },
    visible(newVisiible) {
      if (this.value !== newVisiible) {
        this.$emit('input', newVisiible);
      }
      if (!newVisiible && typeof this.reset === 'function') {
        this.reset()
      }
    },
  },
}
</script>

<style>

</style>
```

### 随手写的 el-form 验证

```
export const validForm = (refForm) => {
  return new Promise((res) => {
    if (refForm.validate){
      refForm.validate((valid) => {
        res(valid);
      } )
    } else {
      res(false)
    }
  })
}
```

## [2023-02-14] vue + typescript + vue-property-decorator 写法总结

有关 typescript 写 vue，最痛苦的是不自由。动不动编译器报错，动不动类型校验通不过。在习惯了信马由缰写代码的 js 后，使用 ts 无异于自插双眼。然而不可否认的是，强制的检查带来了强大的稳定性。以往写代码总是担心各种各样空指针问题，在 ts 中通过强类型校验（interface 声明）和`?`补偿保证代码高度的兼容了 undefined、null 等各种各样的奇葩问题。甚至在声明 `data` 中属性时如果不进行赋值便无法初始化这点，让人又爱又恨。然而当我放弃了各种擦边球和诡异角度，堂堂正正的在 `data` 中写清楚一个超级复杂的属性的数据结构时，我也理解了 `ts` 的这种做法。

Javascript 是爽了现在的自己，坑了别人（和将来维护的自己）。
Typescript 看起来是坑了现在的自己，但是在日后维护以及代码阅读上带来了非常明显的方便。

起码两个小时后回去对源代码修改的我，不用在从 network 里去扒拉数据结构了。

### ts 写法模板

```vue

<!-- eslint-disable @typescript-eslint/camelcase -->
<template>
  <div>
    demo1
    {{props}}
    {{dataA}}
    <div @click="method1"></div>
  </div>
</template>

<script lang="ts">
import { Component, Prop, Vue, Watch } from 'vue-property-decorator'
@Component({
  name: 'Demo1'
})
export default class Demo1 extends Vue {
  @Prop(Boolean) readonly propA?: boolean;

  @Prop({
    type: Object,
    default: () => ({})
  })
  readonly propB?: IDto

  @Prop({
    type: Array,
    required: true,
  })
  readonly propC?: [];


  dataA = false;
  dataB = 123;
  dataC: IDto = {
    key1: 111,
    key2: '222'
  }

  get computedA() {
    return dataA + parseInt(dataC.key2)
  }

  method1() {
    // ....
  }
  async  method2() {
    // ....
    this.$emit('change', this.dataB)
  }

  @Watch('dataA')
  onChangeDataA(newVal: boolean) {
    // ...
  }

  @Watch('dataC', {
    immediate: true,
    deep: true
  })
  onChangeDataC(newDataC: IDto) {
    // ....
  }
}
</script>

<style lang="scss">
</style>


```

## [2023-02-15] 积累

### 有关加水印 

```javascript
const watermark = {}

const setWatermark = (text, sourceBody) => {
  const id =
    Math.random() * 10000 +
    '-' +
    Math.random() * 10000 +
    '/' +
    Math.random() * 10000

  if (document.getElementById(id) !== null) {
    document.body.removeChild(document.getElementById(id))
  }

  const can = document.createElement('canvas')
  can.width = 120 // 设置水印之间的左右间距
  can.height = 80 // 设置水印之间的上下间距

  const cans = can.getContext('2d')
  cans.rotate((-20 * Math.PI) / 180)
  cans.font = '15px Vedana'
  cans.fillStyle = 'rgba(0, 0, 0, .5)'
  cans.textAlign = 'left'
  cans.textBaseline = 'Middle'
  cans.fillText(text, can.width / 20, can.height)

  const water_div = document.createElement('div')
  water_div.id = id
  water_div.className = 'watermarkClass'
  water_div.style.pointerEvents = 'none'
  water_div.style.background =
    'url(' + can.toDataURL('image/png') + ') left top repeat'
  if (sourceBody) {
    water_div.style.width = '100%'
    water_div.style.height = '100%'
    sourceBody.appendChild(water_div)
  } else {
    water_div.style.top = '3px'
    water_div.style.left = '0px'
    water_div.style.position = 'fixed'
    water_div.style.zIndex = '100000'
    water_div.style.width = document.documentElement.clientWidth + 'px'
    water_div.style.height = document.documentElement.clientHeight + 'px'
    document.body.appendChild(water_div)
  }

  return id
}

/**
 *  该方法只允许调用一次
 *  @param:
 *  @text == 水印内容
 *  @sourceBody == 水印添加的位置，不传就是body
 * */
watermark.set = (text, sourceBody) => {
  const domArr = Array.from(document.getElementsByClassName('watermarkClass'))
  for (let i = 0; i < domArr.length; i++) {
    const element = domArr[i]
    element.remove()
  }
  if (text === '') {
    return
  }
  setWatermark(text, sourceBody)
}

export default watermark

```

使用(vue)：

```
import watermark from './utils/watermark'
export default {
  name: 'Demo',
  mounted() {
    watermark.set('水印')
    watermark.set('水印', document.getElementById('app'))
    watermark.set('水印', this.$refs.demo)
  }
}
```

- [Vue - 页面添加水印效果](https://blog.csdn.net/Jie_1997/article/details/120085074)
-[《大前端 基础组件》系列 80行实现一个网页水印npm包](https://juejin.cn/post/6844904113474404360)

### 有关精度丢失的问题

今天联调时连续的几个任务都是获取失败，把 traceid 和任务 id 发给后端时后端一脸懵逼说这 taskid 哪里来的，后端数据库里根本查不到。

仔细查看 network，在 preivew 里看到的值是 23021510400029930，看 response 里返回的居然是 23021510400029928（这个是正确的）。后来查阅文章发现，对于 2^53 - 1 的数据，js 就有加错的风险。最后和后端商量，把返回值改成 string 类型，问题解决。

参考[这里]((https://juejin.cn/post/7051103304780103716))

## [2023-02-16] axios post 请求总结
> 今天给人擦屁股擦了一天，修了无数的 bug 就是因为之前人维护的时候格式不统一、字段不统一，尼玛连查询参数都能有 page 和 pageNo，真的心累。


- 使用 post 发送 json 请求
> axios 默认发送 json 请求，并将非序列化的数据序列化

```javascript
await axios.post('http://test/post', { name: 'John Doe' }, {
    headers: {
    'Content-Type': 'application/json' // 默认是这个，可以不用写
    }
});

```

- 使用 post 发送 x-www-form-urlencoded

```javascript
import qs from 'qs';
const params= { name: 'John Doe' }
axios({
    method: 'POST',
    headers: { 'content-type': 'application/x-www-form-urlencoded' },
    data: qs.stringify(params),   // 用 qs 将js对象转换为字符串 'name=edward&age=25'
    url: 'http://test/post'
}).then(res => {
	console.log(res)
});
```

- 使用 post 发送 formdata

```javascript
import qs from 'qs';
const params= { name: 'John Doe' }
const file = new File('./2023每日积累.md')
const data = new FormData()
data.append('name', params.name)
data.append('file', file)
axios({
    method: 'POST',
    headers: { 'content-type': 'multipart/form-data' },
    data, 
    url: 'http://test/post'
}).then(res => {
	console.log(res)
});
```

## [2023-02-17] chatgpt 研究

最近 chatgpt 比较火，跟风研究了一下。目前的结论是：虽然 chatgpt 能提供一些方便，但是想要代替人工还是远远不如。因为**chatgpt只能解决（已发现的）问题，不能提出（未发现的）问题。**chatgpt 在被我问到是否会写小说时，也大方的承认：我是可以生成一些文本，但是写小说是一个需要人类创意和想象力的任务 ，因此没有能力像人类作家一样创作出高质量的小说。

- [openai 官网](https://openai.com/)

注册的话还是需要翻墙，以及需要处理注册时的地区问题。中国访问还是会受限（包括港澳台），而且注册时需要当地手机号。可以使用[虚拟号码](https://sms-activate.org/)注册一个，也可以请当地朋友提供一个。目测是注册时需要，后期登陆不需要。

同时，还会检测地区设置，需要提前在控制台进行处理。

```
window.localStorage.removeItem(Object.keys(window.localStorage).find(i=>i.startsWith('@@auth0spajs')))
```

然后注册成功。

升级成 plus 版需要当地 visa card，$20 一个月。个人感觉挺便宜，如果开发出用法，后续想升级一个。

一个chatgpt的相关网站：[chatgpt](https://www.w3cschool.cn/openai_doc/openai_doc-rtix3r2t.html)

### 2.19 论如何正确使用 chatgpt

有关 chatgpt，给出答案有效程度和提出的问题精准程度有直接关系。比如“Dota2火猫怎么玩”只会给出一些泛泛的回答，而“Dota2火猫在逆风情况下怎么针对对方的核心小黑”确实能给出一些有用的经验。因此从使用的角度来说，chatgpt 更像是提升工作效率的工具。而用好 chatgpt 的关键，就是问对正确的问题。


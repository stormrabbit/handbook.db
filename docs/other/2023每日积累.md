# 2023 每日积累整理

## [2023-01-03] 统计当前使用者git项目提交代码行数命令问题

### 基本命令

```
git log --since="2022-01-01" --before="2023-01-01" --author="$(git config --get user.email)" --pretty=tformat: --numstat | awk '{ add += $1 ; subs += $2 ; loc += $1 + $2 } END { printf "added lines: %s removed lines : %s total lines: %s\n",add,subs,loc }'
```

### 拓展：改为接受命令行执行 sh

```
# test.sh
# sh test.sh 2022-01-01 2023-01-01
start=$1
end=$2
author="$(git config --get user.email)"

echo "开始日期: ${start}"
echo "结束日期: ${end}"
echo "git user: ${author}"

git log --since="${start}" --before="${end}" --author="$(git config --get user.email)" --pretty=tformat: --numstat | awk '{ add += $1 ; subs += $2 ; loc1 += $1 - $2 ;loc2 += $1 + $2 } END { printf "新增: %s，删除: %s，净增: %s，总计修改: %s\n",add,subs,loc1,loc2 }'
```

#### 小问题

命令最开始使用的是 `gawk`，使用时报错 ` command not found: gawk`，更换为 `awk` 则成功运行。

## [2023-01-04] 有关设置服务器定时任务的构想与步骤拆解

> 买了服务器不知道干啥用，想想怎么能有效把服务器利用起来。

### 步骤

1. 编写简单的脚本 `demo.sh`，脚本内容为：`df -h`。
2. 获取运行结果，保存成文件 `demo-res.txt`。[参考](https://blog.csdn.net/weixin_38370441/article/details/115487340)
   - 每次输出内容如果相同，用日期 `date` 进行简单区分。 
   - sh 日期格式化：`date "+%Y-%m-%d %H:%M:%S"`（注意需要使用 "" 将格式化文本包起来，留有空格会被认为是 2 个命令而报错）。[参考](https://cloud.tencent.com/developer/article/1720961)
3. 使用电子邮件发送 `demo-res.txt`。
   - linux 下通常使用 mailx 发送邮件。
   - mailx 命令：`echo "This is the mail body" | mail -s "Subject" 123@qq.com`
   - mail -s "Hello from jsdig.com by shell" 123@qq.com
   - echo "hello,this is the content of mail.welcome to www.jsdig.com" | mail -s "Hello from jsdig.com by pipe" 123@qq.com
   - 卡住了，走不下去。
4. 定时每天 11 点发送。
   - 使用 linux 常用命令 crontab，一般自带。
     - crontab 是否存在：`rpm -qa | grep crontab`。
     - crontab 是否在运行：`systemctl status crond`，`active (running)` 表示在运行，`inactive (dead)` 表示未运行。
     - crontab 启动：`systemctl start crond` 。
     - [其余常用命令](https://zhuanlan.zhihu.com/p/115082330)。
   - crontab [常用写法](https://www.runoob.com/w3cnote/linux-crontab-tasks.html)。
   - crontab [未正常运行原因参考](https://blog.csdn.net/u011734144/article/details/54576469)。
     - 练手过程中遇到的是路径问题，crontab 实际上是运行了的，但是因为 sh 脚本中 `> demo-res.txt` 是相对路径，所以写入到了 crontab 目录下的 `demo-res.txt`，修改为绝对路径则正常运行。
   - crontab 运行后的其他问题：
     - 有关 `crontab -e` 和 `crontab /etc/crontab` 执行问题：经测试两者分别独立，`crontab -e` 为当前用户计划，不需要也不能指定用户（会报错）；`crontab /etc/crontab` 为总体定时计划，需要指定用户。
     - 运行 `demo.sh` 脚本后会莫名其妙的收到邮件，命令行提示 `You have new mail`。进入 `/etc/mail` 目录下发现 `demo.sh` 脚本的输出结果被输出到了`运行用户名`命名的文件内，原因不明。

#### sh 脚本

```
date "+%Y-%m-%d %H:%M:%S"> demo-res.txt
df -h >> demo-res.txt
cat demo-res.txt
```

#### 后续扩展思考

1. 服务器可以执行哪些脚本？
2. 可以执行的是否只有脚本？
3. 如何定时爬取 steam 打折游戏列表？
4. 以日常维护来说，服务器需要哪些定时任务？
5. 其他项目是否需要定时任务？

#### 好文参考

- [Crontab 定时任务](https://my.oschina.net/u/4313887/blog/3710661)
- [云服务器定时任务方案cron（全流程）](https://juejin.cn/post/6913131133597122568)
- [linux 常用命令](http://mcos.top/archives/linux-chang-yong-ming-ling--wen-jian-cao-zuo--ding-shi-ren-wu--cha-kan-fu-wu-qi-xin-xi-)

## [2023-01-09] 有关数据上报的学习与经验积累
> 参考：[你只会用前端数据埋点 SDK 吗？](https://mp.weixin.qq.com/s/1VWYBLMdl94pyBpOl3p5hQ)

### sdk 存在的意义 - 为什么需要前端数据埋点？

从个人体会，前端埋点的最大意义便是及早发现问题，进而解决问题。后端服务因为有服务器日志方便回溯数据与用户操作，对于问题的定位是非常简洁且高效的。但是前端页面上线后，只能通过用户的描述对操作复现，定位问题成本很高。

而且前端所谓直接应对用户的页面，所以一旦出现 bug 会被用户第一时间感知到。而因为单测编写难度（以及个人懒散），前端工程很多时候都是裸奔上线，解决 bug 只能靠手工测试。对于动辄千万行的代码而言，总有那么几条漏网之鱼。因此每次上线前后都是最担心的，不知道就弄了什么定时炸弹上去。

所以前端埋点的最大意义便是：

- 错误收集
- 性能搜集
- 行为收集

重要性分先后。

### 前端错误收集

前端错误收集分两种：运行时错误与接口错误。

## [2023-01-12] 文章阅读

- [RBAC用户、角色、权限、组设计方案](https://zhuanlan.zhihu.com/p/63769951)
- [【presto】函数大全](https://blog.csdn.net/lz6363/article/details/123769785)
- [git取消对某个文件的跟踪](https://blog.csdn.net/qq_37858386/article/details/105133639)

### git 取消文件 sh 脚本

```
# show-rm-git.sh
doc=$1
echo "即将删除 ${doc} 下的："
git rm -r -n --cached "${doc}"
```

```
# rm-git.sh
doc=$1
echo "已删除 ${doc} 下的："
git rm -r --cached "${doc}"
```

## [2023-01-13] 有关流程图与架构图

- [流程图标准](https://zhuanlan.zhihu.com/p/67533900)
- [如何画好一张架构图](https://juejin.cn/post/6844904192394412040)
> 基本没看懂。
- [架构图和时序图](https://www.imgeek.org/article/825360037)
- [作图](https://www.processon.com/)
> 画图真难，比写代码难的多。

## [2023-01-14] nestjs 打包问题

- [Nest项目部署的最佳方式](https://juejin.cn/post/7065724860688760862)

nestjs 打包部署也是个老大难的问题，主要就是在 build 时 nestjs 并未将 node_modules/ 下的文件打入 dist 文件夹内，只是简单的进行了引用链接。常用的做法有：

1. 将 nestjs 使用的依赖包打成 docker，然后以 docker 镜像 + dist 的方式进行使用。
2. 整个项目打成 zip 包部署（体积比较大）。
  
这边文章提供了第三种方法，引入 webpack 将 node_modules/ 打入 dist 内的 main.js 中。 

## [2023-01-15] rbac 文章复读 & 数据库设计
> [RBAC用户、角色、权限、组设计方案](https://zhuanlan.zhihu.com/p/63769951) 

有关权限的细分，在[权限管理系统数据库设计](../server/权限管理系统数据库设计.md)中权限设计的拓展。

权限为单独的一张权限表：

```
  drop table if exists authorities;

    CREATE TABLE IF NOT EXISTS `authorities`(
   `id` INT UNSIGNED AUTO_INCREMENT,
   `name` VARCHAR(40) NOT NULL comment '权限名称' ,
   `type` VARCHAR(40) NOT NULL comment '权限类型',
   `status` TINYINT NOT NULL DEFAULT 0,
   PRIMARY KEY ( `id` )
)ENGINE=InnoDB DEFAULT CHARSET=utf8;
```
> 与原本相比，增加了 type 类型，保证权限并不仅仅以一种方式进行存在。有可能对菜单的访问权限、对页面元素的访问权限、对某类资源的访问权限，增加了灵活性。

增加功能操作表/限制表：

```
drop table if exists operations;

    CREATE TABLE IF NOT EXISTS `operations`(
   `id` INT UNSIGNED AUTO_INCREMENT ,
   `name` VARCHAR(40) NOT NULL comment '操作名称',
   `code` VARCHAR(40) NOT NULL comment '操作码',
   `url` VARCHAR(80) default '' comment '拦截 url',
   `father_id` INT UNSIGNED default 0 comment '父id',
   `status` TINYINT NOT NULL DEFAULT 0,
   PRIMARY KEY ( `id` )
)ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

增加权限&操作关系表

```
drop table if exists authorities_operations;
CREATE TABLE IF NOT EXISTS `authorities_operations` (
 `a_id` INT UNSIGNED COMMENT '权限id',
 `o_id` INT UNSIGNED COMMENT '操作id',
 `status` TINYINT NOT NULL DEFAULT 0,
 CONSTRAINT `authorit_o`FOREIGN KEY  (`a_id`)  REFERENCES  `authorities` (`id`),
 CONSTRAINT `operation_a` FOREIGN KEY (`o_id`) REFERENCES `operations` (`id`)
) 
```

扩展权限表后，可以对各种类型的资源进行控制。例如菜单、元素、文件：

```
drop table if exists menus;

    CREATE TABLE IF NOT EXISTS `menus`(
   `id` INT UNSIGNED AUTO_INCREMENT ,
   `name` VARCHAR(40) NOT NULL comment '菜单名称',
   `url` VARCHAR(80) default '' comment '菜单 url',
   `father_id` INT UNSIGNED default 0 comment '父级菜单 id',
   `status` TINYINT NOT NULL DEFAULT 0,
   PRIMARY KEY ( `id` )
)ENGINE=InnoDB DEFAULT CHARSET=utf8;

drop table if exists authorities_menus;

 CREATE TABLE IF NOT EXISTS  `authorities_menus` (
 `a_id` INT UNSIGNED COMMENT '权限id',
 `m_id` INT UNSIGNED COMMENT '菜单id',
 `status` TINYINT NOT NULL DEFAULT 0,
 CONSTRAINT `authority_m`FOREIGN KEY  (`a_id`)  REFERENCES  `authorities` (`id`),
 CONSTRAINT `menu_a` FOREIGN KEY (`m_id`) REFERENCES `menus` (`id`)
) 
```

通过权限菜单表，可以对权限进行扩展。

- 权限 - 菜单 - 权限_菜单。
- 权限 - 元素 - 权限_元素。
- 权限 - 文件 - 权限_文件。

#### 参考

- [MySQL的外键约束（FOREIGN KEY](https://juejin.cn/post/6965849361599168520)

## [2023-01-16] nestjs 部署探索

### 方法一：压缩打包法：连同依赖包和依赖配置一同打包进 zip 包。以 zip 包为基准提交 git。缺点：体积大。

```
tar -czvf dist.tar.gz ./dist ./node_modules ./.env
```

### 方法二：[docker 化](https://juejin.cn/post/6992508923953709064)

- `Dockerfile`

```

# Docker多阶段构建

### DEV环境 ###
FROM node:14.17.3 AS development

# 定位到容器工作目录
WORKDIR /usr/src/app
# 拷贝package.json
COPY package*.json ./


RUN npm install --unsafe-perm -ddd --registry=https://registry.npm.taobao.org
# RUN npm install glob rimraf
# RUN npm install --only=development
COPY . .
RUN npm run build


### PROD环境 ###
FROM node:14.17.3 as production

# ARG NODE_ENV=production
# ENV NODE_ENV=${NODE_ENV}

WORKDIR /usr/src/app

COPY package*.json ./

RUN npm install --unsafe-perm -ddd --registry=https://registry.npm.taobao.org
RUN npm install pm2 -g
# RUN \
#   npm config set registry https://registry.npm.taobao.org \
#   && npm install --only=production

COPY . .

# COPY --from=development /usr/src/app/dist ./dist

CMD ["node", "dist/main"]
```

- `docker-compose.yml`

```
version: '3.9'
services:
  dev:
    container_name: server-dev
    image: server-dev:1.0.0
    build:
      context: .
      target: development
      dockerfile: ./Dockerfile
    command: npm run start:debug
    # network_mode: host
    ports:
      - 8080:8080
    volumes:
      - .:/usr/src/app
      - /usr/src/app/node_modules
    restart: always
  prod:
    container_name: server-prod
    image: server-prod:1.0.0
    build:
      context: .
      target: production
      dockerfile: ./Dockerfile
    command: npm run start:prod
    network_mode: host
    # ports:
    #   - 8080:8080
    volumes:
      - .:/usr/src/app
      - /usr/src/app/node_modules
    restart: always
```
> docker-compose 有版本限制，需要在开头 version 标明。版本不同的 docker 

docker 好处是，打包体积确实小。但是 docker 源会比较大。

## [2023-01-17] 有关 vue2 生命周期的复习与整理

| 生命周期钩子 | 组件状态 | 	最佳实践 |
| :-----| :-----| :-----|
| beforeCreated | 实例初始化后，this 指向创建的实例。但是不能访问到 data、computed、watch 和 methods 上的方法和数据 | 常用于初始化非响应式变量 |
| created | 实例创建完成，可访问 data、computed、watch 和 methods 上的方法和数据未挂载到 DOM，不能访问 $el 属性，$ref 属性内容为空数组| 常用于简单的 AJAX 请求，页面的初始化 |
| beforeMount | 在挂载开始之前被调用beforeMount 之前，会找到对应的 template，并编译成 render 函数|  |
| mounted | 实例挂载到 DOM 上，此时可以通过 DOM API 获取到 DOM 节点，$ref 属性可以访问|  常用于获取 VNode 信息和操作，AJAX 请求|
| beforeUpdate | 响应式数据更新时调用，发生在 Virtual DOM 打补丁前| 适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器|
| updated | Virtual DOM 重新渲染和打补丁之后调用，组件 DOM 已经更新，可执行依赖于 DOM 的操作| 避免在这个钩子函数中操作数据，可能陷入死循环|
| beforeDestroy | 实例销毁之前调用。这一步，实例仍然完全可用，this 仍能获取到实例引用| 常用于销毁定时器、解绑全局事件、销毁插件对象等操作|
| destroyed | 实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁	| |

### 额外

- [有关 vue3 生命周期的学习与整理](https://cn.vuejs.org/api/composition-api-lifecycle.html)
- url 与锚点的关系？

## [2023-01-18] 

### vue 锚点跳转

直接上代码

```
<template>
  <div>
    <div id="header">
      <el-button
        @click="toDetail(`${anchor}${anchor}${index}`)"
        v-for="(anchor, index) in anchors"
        :key="anchor"
        >to：{{ anchor }}{{ anchor }}{{ index }}</el-button
      >
    </div>

    <div
      v-for="(anchor, index) in anchors"
      :key="index"
      :id="`${anchor}${anchor}${index}`"
      style="width: 800px; height: 400px; border: 1px solid red; margin: 12px;position: relative;"
    >
      <h3 style="padding: 8px; border-bottom: 1px solid red; margin: 12px">
        {{ anchor }}-{{ anchor }}-{{ index }}
      </h3>
      <p style="margin: 8px">{{ anchor }}{{ anchor }}{{ index }}</p>
      <el-button @click="toDetail('header')" style="position: absolute;right: 12px;bottom: 12px;">回去</el-button>
    </div>
  </div>
</template>

<script>
export default {
  name: 'DemoOne',
  data: () => ({
    temp: 'demo',
    anchors: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'],
  }),
  mounted() {
    const {
      hash = ''
    } = location

    if (hash && hash.slice) {
      this.toDetail(hash.slice(1))
    }
  },
  methods: {
    toDetail(anchorId) {
      console.log(anchorId)
      const scrollDom = document.getElementById(anchorId);
      if (scrollDom) {
        scrollDom.scrollIntoView({
          behavior: 'smooth',
        });
      }

    },
  },
};
</script>


<style>
</style>
```

#### [另一种跳转方法](https://www.jianshu.com/p/2ad8c8b5bf75)

麻烦了些，但是可以避免 hash 路由与锚点冲突。

### 有关拆解的问题

```
let { result = 'default' } = {};
console.log(result); // 'default'

let { result = 'default' } = {result: undefined};
console.log(result); // null

let { result = 'default' } = {result: 1};
console.log(result); // 1

let { result = 'default' } = {result: null};
console.log(result); // null
```
> 所以后端没事儿别瞎鸡儿返回数据

### 有关如何在控制台输出 badge 格式的文字

```
var success='#54c22b'
var primary='#2873b2'
var label='#606060'
var error='red'
let showBadge = function (label ,text, labelColor, textColor) {
        console.log(
            '%c '.concat(label, ' %c ').concat(text, ' '), 
            'padding: 1px; border-radius: 3px 0 0 3px;color: #fff;background: '.concat(labelColor, ';'),
            'padding: 1px; border-radius: 0 3px 3px 0;color: #fff;background: '.concat(textColor, ';'))
      }
showBadge('label', 'txt',label, primary)
```

## [2023-01-20] 为什么程序员讨厌低代码
> [为什么程序员讨厌低代码](https://www.zhihu.com/question/561025857/answer/2734260311)

目前接手维护低代码相关的一个系统，比较难受，主要原因有以下几点：

- 入门成本高，尤其是框架底层经过大量的扩展，功能其实多如牛毛，没有一个人可以完全掌握。很多时候，会做一些重复的开发。
- 码表混乱，尤其是页面级码表。统一不了码表，在码表扩充或者减少时，很容易漏掉某些页面。
- 页面修改无法追溯，代码级的修改可以通过 git 进行方便的回滚、检出；配置文件不列入 git，所以改了什么东西完全看不出来。
- 代码配置同步问题。包括测试环境和生产环境配置往往不同步，尤其是在一些小改动直接在生产环境修改而未同步给测试环境。测试环境如果不知道，依然以测试环境的最新版本版本进行开发，很容易上线配置后覆盖对应功能。其次多人协作开发时，如果不同需求对一个配置进行了修改，在没有 git 的情况下很容易互相覆盖。

### [2023-01-28]补充：有关低代码平台 - 码表统一问题的吐槽&坑 

今天在维护低代码平台的码表问题，有以下几个方面的大坑&需要注意的点：

- 混乱问题：页面之间，码表互不相通，同 key 在多个页面内使用、维护困难；同页面内，有码表从接口获取、有码表从配置获取、有码表从本地代码获取，来源混乱；同页面内码表随组件走而不是页面走，相同 key 的码表多次出现。在缺少文档的情况下，后续维护人员很难掌握所有页面的所有码表。在码表变动时，难保不会出现出现遗漏的问题。
- 部分码表获取接口未区分生产环境与测试环境，进行替换时很容易使用测试的变量覆盖正式变量。
- 同一套码表在多人维护时，很容易未能充分共享造成重复工作 —— 比如对同一（从后端获取的）码表提供了多套接口。
- 对于 label、key、value，有出现同 key 不同 value，同 label 不同 key 的情况，会造成很大程度上的理解困难和维护障碍。
- 对于无用结构或者已废弃接口，在后来人接手又不敢删除的情况下，会造成配置的大量冗余。
- 一个前端用起来很爽、维护起来很操蛋、后端很反感的结构：把码表设计为 map 结构，而不是 key-value 的数组（这是反面教材）。Map 的唯一好处是可以方便的使用 key 进行获取 value 获取，但是缺点却是灾难性的：对（java）后端，map 结构无法直观的用 swagger 展示，不如对象清晰便于维护（而且还要特意做一层对象 to map 的操作）；对于前端，虽然提取 value 方便，但是填充 select 类组件需要做一步 map to array 的数据清洗操作。在低代码平台接口未能提供清洗服务的配置时，这份多余就变成了一个需要改变底层才能适配的开发难题。好孩子不要学。
- 对于一些功能相近的菜单，前端代码可以使用 mixin 等方式进行引用，方便修改；配置需要复制两份，修改时也要改两份。

### [2023-01-30]补充：惹了个乱子

今天更新配置时惹了个乱子，在替换配置的时候不慎把别的页面配置覆盖了另一个页面。在更新了时候，已经提交了配置。因为没有回溯系统，甚至连补救的机会都没有。

还好 qa 环境还有对应页面配置，复制过来调整一下把危机处理了。

针对这种情况，特意把配置存了一份到 git 里。

## [2023-01-22] 有关新的一年技术研究和发展构想（暂定）。

- vue3 [源码学习](https://nlrx-wjc.github.io/Learn-Vue-Source-Code/start/)、[项目研究 & 练手](https://github.com/vue3/awesome-github-vue-latest)。
- 基于 vue3 的前端脚手架。
- Ci/Cd、Jeknins groovy 设置打包与部署。 
- 组件整理 & 组件库建设。
- 常用工具代码整理 & 工具库建设。
- 基于 nestjs 的完整 rbac 权限控制服务端。
- rap2 mock 优化：根据 request 参数返回不同的值。
- docker 部署（包括前端部署与后端部署）。
- 埋点 sdk 相关研究

## [2023-01-25] Flutter 相关研究
> 今天看了 flutter 直播，发现 flutter 进化非常大。
- [官网](https://docs.flutter.dev/)。
- [flutter go](https://github.com/stormrabbit/flutter-go)
- [dart](https://dart.dev/
- [flutter b 站社区](https://space.bilibili.com/344928717/)

## [2023-01-30] 有关本地文档常驻构想&实现

平时经常有些文档或者常用命令需要查询，之前是使用 md 文档进行撰写与保存，但是使用起来有这么几个问题：

- 需要打开新的 ide 窗口，并选择对应路径，麻烦。
- md 文档在未预览情况下，可读性还是差了点。
> 其实主要还是开 ide 选路径麻烦，查起来也麻烦。

考虑到便携（懒），准备做如下操作：
- 把此类文档统一归到某个项目内。
- 使用本地服务器的方式启动该项目，启动后可以直接在浏览器中查看。
- 支持实时编辑，刷新预览。
- 支持命令行一键启动&重载。

文档已经归纳到项目内，本地文档系统选择：[docsify](https://docsify.js.org/#/zh-cn/)。

指定 docsify 读取目录：`docsify init ./docs`

需要在 `./docs` 目录下新建 `_sidebar.md` 并撰写目录，可是用 `node fs` 自动读取 docs 下文件并生成。

使用 `npm init` 初始化 `pacakge.json` 文件，增加 docsify 启动命令并指定端口：`"serve": "docsify serve docs --port 12345"`。

docsify 支持实时修改&预览。

编写 docsify 启动脚本：`run_docsify.sh`

```
#!/bin/bash
out="$(lsof -nP | grep LISTEN | grep 12345)"
outs=(${out//\t/ })  
docsPid=${outs[1]}
if [ ! "$docsPid" = "" ]
then
    kill $docsPid
    echo "已经关闭 pid：${docsPid}，正在重启..."
else
    echo '正在启动...'
fi
cd ~/docsify
npm run serve
```

修改 zsh 命令（或者 bash）`vim ~/.zshrc `，指定别名：

```
alias start='sh ~/docsify/run_docsify.sh'

```

重新 source 下：source ~/.zshrc

可以直接使用 start 启动文档服务。

### [2023-02-02] 增加 node 版本运行方式

使用命令行启动，多少还是有些麻烦 —— 要多开一个命令行窗口。因此又使用 node exec 写了一段 js 代码，可以直接用 pm2 启动。

| 启动方式 | 优点 | 	缺点 |
| :-----| :-----| :-----|
| 命令行| 节省电脑资源，不用时可以关闭| 需要多开一个命令行窗口|
| 屏幕| 省心，启动后不用特意开启/关闭| 留在电脑内确实一直占资源|

总的来说两种方式各有优劣吧。

pm2 启动 `run-node.js`：


```

const util = require("util");
const child_process = require("child_process");
// 调用util.promisify方法，返回一个promise,如const { stdout, stderr } = await exec('rm -rf build')
const exec = util.promisify(child_process.exec);

const run = async () => {
  let docsifyRunningStatusStr;
  try {
    const { stdout } = await exec("lsof -i tcp:14841");
    console.log(stdout);
    if (!!stdout) {
      docsifyRunningStatusStr = stdout;
    }
  } catch (_) {
    console.log("正在启动 docs 服务...");
  }

  try {
    if (docsifyRunningStatusStr) {
      console.log("已有服务运行，正在关闭中...");
      const [_, pid] = docsifyRunningStatusStr
        .split(" ")
        .filter((str) => !!str);
      if (pid) {
        const { stdout: closeStatus } = await exec(`kill -9 ${pid}`);
        console.log(closeStatus);
        console.log(`已关闭进程：${pid}`);
      }
    }
  } catch (error) {
    console.log(error);
  }
  try {
    await exec(
      `cd ~/docsify`
    );
    exec(`docsify serve docs --port 14841`);
    console.log("服务已启动，端口 14841");
  } catch (error) {
    console.log("启动失败：");
    console.log(error);
  }
};
run();

```

### [2023-02-06] 文章阅读与参考&工具库想法

- 文章阅读&参考
  - [MarkDown 语法参考](https://markdown.com.cn/basic-syntax/)
  - [JsDoc 写法](https://segmentfault.com/a/1190000015778930)
  - [node 运行 shell 方式参考](https://cloud.tencent.com/developer/article/1812689)
  - [web worker 加快前端渲染](https://mp.weixin.qq.com/s/HbrMoFNFWMlbkVwLol3PoA)
- 工具库构想1 todo：
  - node 执行 shell 脚本工具。
  - document 获取页面尺寸工具。
  - 封装好的 axios 接口工具。
  - 以 typesrcipt 编写。

### [2023-02-07] 文章阅读与参考&组件库构想

- 文章阅读&参考：
  - [RAP2接口管理工具使用教程](https://juejin.cn/post/6850418118772064270#heading-5)（主要是 mock 占位符）
- 组件库思考：
  - 常用 form，使用共同组建。
  - 常用 table ，带查询、分页、渲染。
  - 常用 select 表单项。
  - 多行文字一行显示/鼠标悬浮显示完整。

### [2023-02-08] [有关 js 中的码表枚举化](https://blog.csdn.net/qq_33551792/article/details/108587604)

开发中使用码表的时候，常用两种方式：

方案一：
```
const map = {
  1: '状态一',
  2: '状态二'.
  3: '状态三'
}
```
方案二：
```
const map = [
  {label:'状态一', value: 1 },
  {label:'状态二', value: 2},
  {label:'状态三', value:3 },
]
```

方案一的好处是，对于给定的 key `val`，可以很方便的替换 `map[val]` 获取值。但是一来方案一的扩展性有限，其次对于后端（尤其是 java 后端），返回一个 map 结构并不是标准的流程。

方案二的优缺点刚好和方案二想法，即对于给定的 key `val`，必须使用 `map.find( it => it.value === val)` 才能拿到特定的码表，还要处理找不到值(undefined)的情况；但是结构方便扩展，java 返回的也通常是此种类型。

但是方案一和方案二都无法解决的是，在除了值替换过程中的一些逻辑判断时提供足够的语义化支持。比如对给定的值 val，在 `1,2,3` 情况下要做特定的操作，有 `val === 1/2/3` 这就不够友好。且不说维护时会想半天 123 都是啥东西，如果需要对值进行修改，光改就要改半天。

因此应该对码表进行枚举化改造，并对枚举值提供 get 和转义操作，将所有的操作收敛到对应的常量方法中，方便对于状态的管理。

```
// 在文章的基础上进行了改造
function createEnum(definition) {
  const strToValueMap = {}
  const numToDescMap = {}
  for (const enumName of Object.keys(definition)) {
    const [value, desc] = definition[enumName]
    strToValueMap[enumName] = value
    numToDescMap[value] = desc
  }
  return {
    ...strToValueMap,
    toOptions() {
      return Object.keys(strToValueMap).map(key=> ({
        label: this.emun2Text(key),
        value: strToValueMap[key]
      }))
    },
    emun2Text(enumName) {
      return (definition[enumName] && definition[enumName][1]) || ''
    },
    value2Text(value) {
      return numToDescMap[value] || ''
    }
  }
}

```

然后有

```
// STATIS1/2/3 是瞎写的，实际应该是 APPROVE/REJECT 等更为有语义化的单词，方便代码阅读
export const STATIS = createEnum({
  STATIS1: [1, '状态1'],
  STATIS2: [2, '状态2'],
  STATIS3: [3, '状态3'],
})
```

对于 select 等组件需要的 options 选项

```
STATIS.toOptions()
```

对于需要转义的地方

```
STATIS.value2Text(val)
```

对于需要逻辑判断的地方

```
switch(val) {
  case STATIS.STATIS1:
    ....
  case STATIS.STATIS2:
    ....
  case STATIS.STATIS3:
    ....
  default:
    ....
    
}
```

当然，枚举化也有自己的问题。即对于灵活变化的码表或者量大的码表（比如城市码表、由接口获取的码表），无法使用给定的枚举值进行枚举化。还是要回归到方案二的老路上。

方案一可以通过方案二清洗数据转化的来，最好不要让后端直接返回。后端会炸毛，有结构变动或者扩充的时候前端后端会一起炸毛。


